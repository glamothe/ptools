\documentclass[12pt,a4paper]{article}
\usepackage{ae}
\usepackage{aecompl}
%\usepackage[cm]{aeguill}
\textwidth 16.5cm \textheight 26cm \oddsidemargin -0.5cm \topmargin -2cm
\usepackage{graphicx} % figures
\usepackage{lineno}

\usepackage{hyperref}
\newcommand{\simplelink}[1]{\htmladdnormallink{#1}{#1}}


\begin{document}

\setlength{\parindent}{0pt}


\title{\bf PTools tutorial}

\author{Adrien Saladin $^{1,2}$
\and S\'ebastien Fiorucci$^{1,4}$
\and Pierre Poulain$^3$
\and Chantal Pr\'evost$^2$
 and Martin Zacharias$^1$
}

\maketitle
\thispagestyle{empty}

\noindent
{\scriptsize
$^1$ Computational Biology, School of Engineering and Science, Jacobs University Bremen, 28759 Bremen, Germany\\
$^2$ LBT, CNRS UPR 9080 and Univ. Paris Diderot - Paris 7, IBPC, 13 rue Pierre et Marie Curie, 75005 Paris, France   \\
$^3$ DSIMB team, Inserm UMR-S 665 and Univ. Paris Diderot - Paris 7, INTS,
6 rue Alexandre Cabanel, 75015 Paris, France   \\
$^4$ LCMBA, UMR-CNRS 6001, Facult\'e des Sciences, Universit\'e de Nice-Sophia Antipolis, 06108 Nice Cedex 2, France. \\
}

\vspace*{1cm}
\begin{figure}[htbp]
\center
\includegraphics*[width=0.80\linewidth]{img/docking.png}
\end{figure}

\vspace*{1cm}
If you use PTools, please cite: \\
A.~Saladin, S.~Fiorucci, P.~Poulain, C.~Pr\'evost, and M.~Zacharias,\\
PTools: an opensource molecular docking library,\\
BMC Structural Biology 9: 27 (2009).

\vspace*{1cm}

\noindent
This tutorial presents the PTools library features and its docking application ATTRACT.

\newpage

\tableofcontents{}

\newpage

\section{Set up, compilation and installation}

\subsection{Basic requirements}

The basic requirements are:
\begin{itemize}

\item g++ (4.x)
\item gfortran (4.x) or g77
\item doxygen (optional)
\item the Boost C++ library
\item SCons
\end{itemize}

The following tools are also necessary in order to use the library as a Python module:
\begin{itemize}
\item Python 2.4 or 2.5 and its development library (python2.4-dev or python2.5-dev)
\item gccxml (may require cmake and cvs if you need to compile it from sources).
\item pygccxml
\item py++
\item the Boost.Python library (which is not part of the main Boost C++ library on some linux distributions)
\end{itemize}

Software locations and install instructions will be given below.

In the following, we assume the PTools library will be installed in the 
\verb@$HOME/soft@ directory where \verb@$HOME@ represents the home directory
(usually {\tt /home/adrien} for the user {\tt adrien}).


\subsection{Installing prerequisites}

\subsubsection{On Debian or Debian-like systems (Ubuntu)}

\begin{verbatim}
apt-get install scons libboost-dev libboost-python-dev gccxml
\end{verbatim}
%
See \ref{pyplusplus} for installing necessary tools for building python bindings.


\textbf{Note}: some Debian Ubuntu systems have an old version of gccxml that doesn't work well for binding this
library. If bindings generation or unit tests fail, you should consider installing gccxml manually (see \ref{gccxml})

gccxml version $\le 0.6$ crash during bindings generation. gccxml v. $0.9$ from Debian Lenny contains a bug that prevents some Python unit tests to work (test 16 fails).
gccxml package on Debian squeeze (future stable) looks fine (at least for version 0.9.0+cvs20100501-2).


\subsubsection{On Fedora systems}

\paragraph{SCons (make substitute):}
The scons package provided by Fedora is not up-to-date enough to link Fortran and C++ together and then rise an
error. The last version of scons is obtained at the homepage of the project ({\tt  http://www.scons.org/}).
From the download section \footnote{\tt http://sourceforge.net/project/showfiles.php?group\_id=30337}, 
get the stable file {\tt scons-0.98.5-1.noarch.rpm} and install it:

\begin{verbatim}
 rpm -ivh scons-0.98.5-1.noarch.rpm
\end{verbatim}

\textbf{Note}: SCons 0.98.5 and 1.0.0 were successfully tested


You can then install some packages:

\begin{verbatim}
  yum install boost boost-devel python-devel
\end{verbatim}


After that, you still need to manually install gccxml, pyplusplus and pygccxml (see below).


\subsubsection{gccxml\label{gccxml}}

The homepage of {\tt gccxml} project is {\tt http://www.gccxml.org} and its official 
CVS repository is {\tt http://www.gccxml.org/HTML/Download.html}.

\begin{verbatim}
cvs -d :pserver:anoncvs@www.gccxml.org:/cvsroot/GCC_XML login
\end{verbatim}
(just press enter when prompted for a password)\\
Follow this command by checking out the source code:
\begin{verbatim}
cvs -d :pserver:anoncvs@www.gccxml.org:/cvsroot/GCC_XML co gccxml
mkdir gccxml-build
cd gccxml-build
cmake ../gccxml -DCMAKE_INSTALL_PREFIX:PATH=/installation/path
make
make install
\end{verbatim}
The \verb@-DC_MAKE_INSTALL_PREFIX@ option can be left off if you want to use \verb@/usr/local@ as the installation prefix.


\subsubsection{Pyplusplus and Pygccxml: \label{pyplusplus}}
The homepage of {\tt pyplusplus} and {\tt pygccxml} projects is\\ \simplelink{http://www.language-binding.net/pygccxml/download.html}. From the
download section  \simplelink{http://sourceforge.net/projects/pygccxml/files/},
get the files {\tt pygccxml-1.0.zip} and {\tt pyplusplus-1.0.0.zip}.

\begin{verbatim}
unzip pygccxml-1.0.zip
cd pygccxml-1.0/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

\begin{verbatim}
unzip pyplusplus-1.0.0.zip
cd Py++-1.0/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

In your {\tt \$HOME/.bashrc} file, then add:
\begin{verbatim}
export PATH=$PATH:$HOME/soft/bin/
export PYTHONPATH=$PYTHONPATH:$HOME/soft/lib/python2.4/site-packages/
\end{verbatim}

In a Python shell (obtained with the {\tt python} command), test the installation
of PyPlusPlus:
\begin{verbatim}
>>> import pyplusplus
\end{verbatim}






\subsection{Compilation}

Download the PTools library and untar it:

\begin{verbatim}
tar zxvf ptools-XX.tar.gz
\end{verbatim}
The directory {\tt ptools-XX} should be created.


\subsubsection{Static pure C++ library}

Move into the new directory and type:

\begin{verbatim}
 scons cpp
\end{verbatim}

This should create the file {\tt libptools.a}.

If SCons cannot locate a fortran compiler or a library, you can define a search path at the beginning of
the {\tt SConstruct} file.

\subsubsection{The library as a Python module}

From the PTools main directory ({\tt \$HOME/soft/ptools-XX}), 
first create the Python/C++ interface:
\begin{verbatim}
python interface.py
\end{verbatim}

Then compile the library:
\begin{verbatim}
scons
\end{verbatim}

Note that {\tt scons -j2} compiles with two processors in parallel.

If SCons cannot locate a fortran compiler or a library, you can define a search path at the beginning of
the {\tt SConstruct} file.


\subsection{Final test and further documentation}

\subsubsection{C++ library only}

The PTools library has a new C++ unit test system. To try it move into the {\tt Tests/} directory and
type: 
\begin{verbatim}
 make testcpp
\end{verbatim}

You should get something like this:

\begin{verbatim}
running C++ tests
python cxxtestgen.py --error-printer ptoolstest.h > runner.cpp
g++ runner.cpp -I.. -I. -L.. -lptools -o ptoolstest.bin
./ptoolstest.bin
Running 15 tests...............OK!
\end{verbatim}


\subsubsection{Python module}
In the {\tt Tests} directory, one can test that the compilation worked:
\begin{verbatim}
python unittest1.py
\end{verbatim}

The expected output should be similar to:
\begin{verbatim}
...............
----------------------------------------------------------------------
Ran 16 tests in 0.316s

OK
\end{verbatim}


\section{PTools library usages and capabilities}

\subsection{Directly from C++}

Source code may be parsed by Doxygen, an automatic documentation generator.
This documentation may help for the C++ (and indirectly for the Python)
part of the library. 

If Doxygen is installed, simply type {\tt doxygen} in
the directory which contains the {\tt Doxyfile} ({\tt
\$HOME/soft/ptools-XX}). Then look into the {\tt html}
directory and open with your favorite web browser the {\tt index.html} file
generated by doxygen. 

The most important objects and functions to manipulate PDB files are explained in
the following section.

\subsection{From Python through the C++ binding}

If PTools has been installed in the \verb@$HOME/soft/ptools-XX@ directory, 
update your {\tt PYTHONPATH} environment variable accordingly:

\begin{verbatim}
export PYTHONPATH=$PYTHONPATH:$HOME/soft/ptools-XX/
\end{verbatim}
or add this line at the end of your \verb@$HOME/.bashrc@ file.


From the Python interpreter or from a Python script, 
first load the PTools library:
\begin{verbatim}
from ptools import *
\end{verbatim}


\subsubsection{Rigidbody objects}

\paragraph{Load PDB file (for instance {\tt 1BTA.pdb}) into a rigidbody
object.}
\begin{verbatim}
pdb = Rigidbody("1BTA.pdb")
\end{verbatim}


\paragraph{Number of atoms.}
\begin{verbatim}
pdb.Size()
\end{verbatim}


\paragraph{Maximum distance (in \AA) from geometric center.}
\begin{verbatim}
pdb.Radius()
\end{verbatim}


\paragraph{Radius of gyration (in \AA).}
\begin{verbatim}
pdb.RadiusGyration()
\end{verbatim}


\paragraph{Structure translation.}
First create a translation vector as a Coord3D object (for instance +5~\AA\ along the X axis, -3~\AA\ along Y and +1~\AA\ along the Z axis):
\begin{verbatim}
trans = Coord3D(5, -3, 1)
\end{verbatim}
Then, apply the translation vector {\tt trans}:
\begin{verbatim}
pdb.Translate(trans)
\end{verbatim}


\paragraph{Center structure to origin.}
\begin{verbatim}
pdb.CenterToOrigin()
\end{verbatim}


\paragraph{Save structure as PDB file.}
\begin{verbatim}
WritePDB(pdb, "1BTA_centered.pdb")
\end{verbatim}


\paragraph{Superpose two structures.} This is a complete example where we
superpose a structure and its copy after a translation.\\

\noindent
First, load a PDB file as a Rigidbody object
\begin{verbatim}
pdb = Rigidbody("1BTA.pdb")
\end{verbatim}
Make a copy
\begin{verbatim}
pdb2 = Rigidbody(pdb)
\end{verbatim}
Create a translation vector
\begin{verbatim}
trans = Coord3D(5, 0, 1)
\end{verbatim}
Apply the translation on the copy
\begin{verbatim}
pdb2.Translate(trans)
\end{verbatim}
Superpose both structures
\begin{verbatim}
sup = superpose(pdb, pdb2)
\end{verbatim}
Extract RMSD and matrix
\begin{verbatim}
rmsd = sup.rmsd
matrix = sup.matrix
\end{verbatim}
Print RMSD
\begin{verbatim}
print rmsd
\end{verbatim}
The output is {\tt 1.22224104574e-07} (in \AA). Then print the $4 \times 4$ matrix:
\begin{verbatim}
matrix.Print()
\end{verbatim}
with output:
\begin{verbatim}
1  8.07909e-09  -5.80388e-09  1.42535e-09  
-8.07909e-09  1  2.0426e-09  2.54026e-08  
5.80388e-09  -2.0426e-09  1  -1.86091e-08  
0  0  0  1  
\end{verbatim}


\subsubsection{Selection objects}

\paragraph{Select CA atoms.}
\begin{verbatim}
sel_ca = pdb.CA()
\end{verbatim}


\paragraph{Select backbone atoms.}
\begin{verbatim}
sel_bkbn = pdb.Backbone()
\end{verbatim}


\paragraph{Select by chain.}
\begin{verbatim}
sel_chainA = pdb.SelectChainId("A")
sel_chainB = pdb.SelectChainId("B")
\end{verbatim}


\paragraph{Select a range of residues.}
\begin{verbatim}
sel_res = pdb.SelectResRange(10, 20)
\end{verbatim}


\paragraph{Get the number of atomes (the size) of a selection.}
\begin{verbatim}
sel_res.Size()
\end{verbatim}



\paragraph{Reunion between two selections.}
\begin{verbatim}
sel_chainAB = sel_chainA | sel_chainB
\end{verbatim}
or directly
\begin{verbatim}
sel_chainAB = pdb.SelectChainId("A") | pdb.SelectChainId("B")
\end{verbatim}


\paragraph{Convert selection to rigidbody object.}
\begin{verbatim}
ca_trace = sel_ca.CreateRigid()
\end{verbatim}

\subsubsection{atom objects}

\paragraph{Copy atom from rigidbody object.} In this example, the third atom (indexed as 2 since the first atom in numberered 0) is copied.
\begin{verbatim}
at = pdb.CopyAtom(2)
\end{verbatim}

\paragraph{Set new coordinates}
\begin{verbatim}
new_XYZ = Coord3D(2.1,3.9,5.5)
at.SetCoords(new_XYZ)
\end{verbatim}

\paragraph{Translate atom}
\begin{verbatim}
vector = Coord3D(1.0,1.0,1.0)
at.Translate(vector)
\end{verbatim}


\paragraph{Print atom in pdb-like format}
\begin{verbatim}
at.ToPdbString()
\end{verbatim}

\paragraph{Get atom properties}
\begin{verbatim}
at.GetType()
at.GetResidType()
at.GetAtomCharge()
at.GetChainId()
at.GetResidId()
at.GetAtomId()
at.GetExtra()
\end{verbatim}

\paragraph{Set atom properties}
\begin{verbatim}
at.SetType()
at.SetResidType()
at.SetAtomCharge()
at.SetChainId()
at.SetResidId()
at.SetAtomId()
at.SetExtra()
\end{verbatim}

\section{Docking with PTools: ATTRACT}

This part shows the PTools docking application called ATTRACT\cite{Zacharias2005}. Its usage and 
capabilities are illustrated by the docking of a protein--protein complex (1CGI) 
and a protein--DNA complex\cite{Poulain2008} (1K79). The first example (1CGI) is explained 
step by step and scripts usages are exhaustively detailled. The second example 
(1K79) is much more straightforward.

To get system-wide access to all ATTRACT tools, update your PATH and PYTHONPATH accordingly in your \verb@$HOME/.bashrc@ file:
\begin{verbatim}
ATTRACTPATH="$HOME/soft/ptools-XX/PyAttract"
export PATH="$PATH:$ATTRACTPATH"
export PYTHONPATH="$PYTHONPATH:$ATTRACTPATH"
\end{verbatim}


\subsection{Protein--protein complex: 1CGI}

The 1CGI complex \footnote{\tt http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=1CGI} 
has two partners,
\begin{itemize}
\item the bovine chymotrypsinogen A: chain E, 245 residues, 1799 atoms
\item a variant of the human pancreatic secretory trypsin inhibitor: chain I, 56 residues, 440 atoms
\end{itemize}

\subsubsection{Extraction of the docking partners}

Before docking, one has to separate both partners. This is possible with vizualisation
software such as Pymol \footnote{\tt http://pymol.sourceforge.net/} or VMD \footnote{\tt http://www.ks.uiuc.edu/Research/vmd/}, 
and also directly with PTools.

Within the Python interpreter, first load the PTools library:
\begin{verbatim}
from ptools import *
\end{verbatim}

Read the PDB file of the complex:
\begin{verbatim}
pdb=Rigidbody("1CGI.pdb")
\end{verbatim}

The chain selection allows the separation between chain E and I.
\begin{verbatim}
selectE=pdb.SelectChainId("E")
selectI=pdb.SelectChainId("I")
\end{verbatim}

Create both chains as independant Rigidbody objects and save them in PDB files. 
The largest protein is defined as the receptor (chain E) and the smallest 
as the ligand (chain I).

\begin{verbatim}
protE=selectE.CreateRigid()
protI=selectI.CreateRigid()
WritePDB(protE,"receptor.pdb")
WritePDB(protI,"ligand.pdb")
\end{verbatim}
Or more quickly:
\begin{verbatim}
WritePDB(selectE.CreateRigid(),"receptor.pdb")
WritePDB(selectI.CreateRigid(),"ligand.pdb")
\end{verbatim}

\subsubsection{Coarse grain reduction}

This step translates all-atom molecules into coarse grain (reduced) molecules for further docking. 

For the receptor: 
\begin{verbatim}
reduce.py --prot receptor.pdb > receptor.red
\end{verbatim}
In the present case, {\tt receptor.red} contains 522 beads.\\

For the ligand:
\begin{verbatim}
reduce.py --prot ligand.pdb > ligand.red
\end{verbatim}
In this example, {\tt ligand.red} contains 126 beads. \\

The {\tt reduce.py} script requires the following parameters:

\begin{itemize}
\item \verb@--prot@ or \verb@--dna@ option, specifies the type of molecule to reduce (respectively protein or DNA)
\item an input all-atom PDB file, for instance {\tt receptor.pdb}
\item an output coarse grain file, for instance {\tt receptor.red}
\end{itemize}

This script also needs some definition files, located in the \verb=reduce_data= directory:

\begin{itemize}
\item beads topology files ({\tt at2cg.prot.dat} for protein reduction and {\tt at2cg.dna.dat} for DNA reduction )
\item forcefield parameters file ({\tt ff\_param.dat})
\item filetypes conversion file ({\tt type\_conversion.dat})
\end{itemize}

The reduced files generated are PDB-like structure files that can be read by many visualization programs (Rasmol, Pymol, VMD). Always visualize both all-atom and coarse grain structures to check the reduction worked properly (see Fig.~\ref{1CGI_at_cg} for 1CGI).

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.30\textwidth]{img/1CGI_receptor.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.25\textwidth]{img/1CGI_ligand.png}
\caption{All-atom (green sticks) and reduced (red spheres) representation of 
both proteins in the 1CGI complex. Receptor (A) and ligand (B).}
\label{1CGI_at_cg}
\end{figure}

\subsubsection{Initial ligand positions}

Rigid body movements in translational and rotational space can be described
with 3 variables or degrees of freedom ($x$, $y$ and $z$) in translation 
and 3 variables ($\phi$, $\psi$ and $\theta$) in rotation. The rigid body 
transformation is illustrated in Fig.~\ref{rigid_body}.

\begin{figure}[!htbp]
\center
\includegraphics*[width=0.4\textwidth]{img/rigid_body_freedom.png}
\caption{Rigid body transformation in translational and rotational space.}
\label{rigid_body}
\end{figure}



\textbf{Translations}\\
For the purpose of a systematic docking simulation, (translational) 
starting points are placed  all around the
receptor. The Python script {\tt translate.py} employs a slightly modified
Shrake and Rupley \cite{Shrake1973} method to define starting positions
from the receptor surface. The surface generation functions are implemented in
the PTools library. The script first reads the coarse grain (reduced)
receptor and ligand files, then generates a grid of points at a certain
distance from the receptor and outputs the grid with a given density.

Note: a density option ({\tt -d}) controls the minimum distance between starting
points (in \AA). The default value is 10.0~\AA. 

In the present case:
\begin{verbatim}
translate.py receptor.red ligand.red > translation.dat
\end{verbatim}

Vizualization of the starting points may be obtained with any vizualisation 
software by renaming {\tt translation.dat} in {\tt translation.pdb} and then
by removing the first line of {\tt translation.pdb} (that indicates the total 
number of starting points). In this example, Fig.~\ref{1CGI_translation} shows
the receptor surounded by the 204 starting points.

\begin{figure}[htbp]
\center
\includegraphics*[width=0.4\textwidth]{img/1CGI_translation.png}
\caption{Coarse grain receptor in green spheres and starting points as orange spheres.}
\label{1CGI_translation}
\end{figure}

\textbf{Rotations}\\
Each position in translation (\textit{i. e.} each {\tt ATOM} line of the file {\tt translation.dat})
is associated with a certain number of rotations corresponding to the three ($\phi$, $\psi$ and $\theta$) 
rotational degrees of freedom. The rotation distribution is detailed in the file {\tt rotation.dat},
which has the following format:

\linenumbers*
\begin{verbatim}
      7   6
    0.0   1
   30.0   5
   60.0   9
   90.0  13
  120.0   9
  150.0   5
  180.0   1
\end{verbatim}
\nolinenumbers

First item of line 1 indicates the number of $\phi$ angles (7) that are listed underneath 
(0.0, 30.0, 60.0, 90.0, 120.0, 150.0 and 180.0 $^\circ$). In the second column, the item on line 1 is the number of $\theta$ angles (here 6). Figures underneath are the number of $\psi$ angles associated to each $\phi$ angle.

For instance, with $\phi$ = 30 $^\circ$, there are 5 $\psi$ angles (equally distributed on a circle, \textit{i. e.} 72, 144, 216, 288 and 360 $^\circ$) and 6 $\theta$ angles.
In total, there are $ (1 + 5 + 9 + 13 + 9 + 5 + 1) \times 6 = 258$ rotations per translation.

\bigskip
Ultimately, there are in this example a total of 204 starting points $\times$ 258 rotations 
that gives 52,632 starting geometries for the ligand.


\subsubsection{ATTRACT parameters}

ATTRACT parameters are found in the file {\tt attract.inp}, which typical content is:

\linenumbers*
\begin{verbatim}
    6    0    0
 -34.32940  38.75490  -3.66956   0.00050
  100  2  1  1  1  0  0  0  1  9900.00
  100  2  1  1  1  0  0  0  1  1500.00
  100  2  1  1  1  0  0  0  1  1000.00
   50  2  1  1  1  0  0  0  0   500.00
   50  2  1  1  1  0  0  0  0   500.00
   50  2  1  1  1  0  0  0  0   500.00
\end{verbatim}
\nolinenumbers

Line~1 indicates the number of minimisations performed by ATTRACT
for each starting position (six in the present case). The last six lines (3--8) 
are the characteristics of
each minimisation. The first column is the number of steps before the
minimisation stops.  The last column is the square of the cutoff distance
for the calculation of the interaction energy between both partners. 
In the present case, the simulation starts with a very large cutoff value of 9900~\AA$^2$ 
($\sim$ 99~\AA), which is gradually dicreased
to end with 500~\AA$^2$ ($\sim$ 22~\AA).

\paragraph{Note:} Columns with zeros or ones should not be modified, as
well as line~2. They are used for internal development purposes.

\subsubsection{Simple optimization}

A standard simulation with ATTRACT requires:
\begin{itemize}
\item the ATTRACT Python script ({\tt  attract.py})
\item a coarse grain receptor (fixed partner) file ({\tt receptor.red})
\item a coarse grain (mobile partner) file ({\tt ligand.red})
\item the coarse grain parameters ({\tt aminon.par})
\item translation starting points ({\tt translation.dat})
\item rotations performed for each translation starting point ({\tt rotation.dat})
\item docking parameters ({\tt attract.inp})
\end{itemize}

ATTRACT can be used with different options.
\begin{itemize}
\item \verb@-r@ or \verb@--receptor@ (mandatory): defines the receptor file.
\item \verb@-l@ or \verb@--ligand@ (mandatory): defines the ligand file.
\item \verb@ -s@ (optional): performs one single serie of minimisations with the ligand in its initial position.
\item \verb@--ref@, (optional) provides a ligand PDB file as a reference (reduced). After each docking, the RMSD is calculated between this reference structure and the simulated ligand.
\item \verb@--t transnb@ (optional): loads only the translation number {\tt transnb} (and all its associated rotations). This option is very usefull for dispatching a simulation over a cluster of computers.
\item \verb@-h@ or \verb@--help@ (optional): reminds possible options.
\end{itemize}


A single ATTRACT simulation (optimization) may thus be obtained by:
\begin{verbatim}
attract.py -r receptor.red -l ligand.red --ref=ligand.red -s > single.att
\end{verbatim}

The first PDB file provided must be the receptor file (and the second the ligand).
The content of the output file {\tt single.att} is the following:

\newpage
\linenumbers*
\begin{verbatim}
**********************************************************************
**                                                                  **
**                ATTRACT  (Python edition)                         **
**                based on the PTools library                       **
**                                                                  **
**********************************************************************
PTools revision 437
from branch bug539468
unique id pierre_poulain-20100603130128-awuyfelj7avtls54

Start time: 2010-06-03 18:50:57.506277
Reading parameters file: attract.inp
6 series of minimizations
rstk =  0.0005
Reading receptor (fixed): receptor.red with 246 particules
Reading  ligand (mobile): ligand.red with 162 particules
Reading reference file: ligand.red with 162 particules
Single mode simulation
@@@@@@@ Translation nb 1 @@@@@@@
----- Rotation nb 1 -----
{{ minimization nb 1 of 6 ; cutoff= 99.50 (A) ; maxiter= 100
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  69 iterations
{{ minimization nb 2 of 6 ; cutoff= 38.73 (A) ; maxiter= 100
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  9 iterations
{{ minimization nb 3 of 6 ; cutoff= 31.62 (A) ; maxiter= 100
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  13 iterations
{{ minimization nb 4 of 6 ; cutoff= 22.36 (A) ; maxiter= 50
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  11 iterations
{{ minimization nb 5 of 6 ; cutoff= 22.36 (A) ; maxiter= 50
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  3 iterations
{{ minimization nb 6 of 6 ; cutoff= 22.36 (A) ; maxiter= 50
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  1 iterations
      Trans    Rot          Ener    RmsdCA_ref
==        1      1   -58.4463779 1.23525236672
### MAT BEGIN
MAT        0.9941915     -0.0969983      0.0466331      0.4410928 
MAT        0.0984211      0.9947151     -0.0292441     -1.1030090 
MAT       -0.0435501      0.0336639      0.9984839      0.5793707 
MAT        0.0000000      0.0000000      0.0000000      1.0000000 
### MAT END

Saved all minimization variables (translations/rotations) in minimization.trj
End time: 2010-06-03 18:50:58.031199
Elapsed time: 0:00:00.524922
\end{verbatim}
\nolinenumbers

\begin{itemize}
\item{\bf lines 1--6:} header
\item{\bf lines 7--9:} PTools library revision, branch and unique id
\item{\bf line 11:} starting date and time of the simulation
\item{\bf lines 21--23:} minimization 1. Minimization index, cutoff 
in \AA\ and maximum number of iterations (line~21). 
Number of variables (line~22). End of minimization (line~23), either 
convergence is achieved (the number of performed iterations is specified), 
either maximum number of steps is reached.
\item{\bf lines 24--26:} minimization 2.
\item{\bf lines 27--29:} minimization 3.
\item{\bf lines 30--32:} minimization 4.
\item{\bf lines 33--35:} minimization 5.
\item{\bf lines 36--38:} minimization 6.
\item{\bf lines 39--40:} final result after the 6 minimizations. With a single series of minimization, the default translation ({\tt Trans}) is 1 and the default rotation ({\tt Rot}) is 1. 
Energy ({\tt Ener}) is given in RT unit and the C$_{\alpha}$-RMSD 
({\tt RmsdCA\_ref}) in \AA\ if the \verb@--ref@ option is specified.
\item{\bf lines 41--46:} rotation/translation matrix of the ligand compared to its initial position.
\item{\bf line 49:} end date and time of the simulation.
\item{\bf line 50:} elapsed time for the simulation
\end{itemize}

Here, the final energy is -58.4~RT unit and the RMSD is 1.2~\AA, which is pretty close from the initial position. (In a \emph{perfect} simulation, RMSD would be, of course, 0.0~\AA).

\subsubsection{Systematic docking simulation}

For a full systematic docking in the translational and rotational space (using both {\tt translation.dat} and {\tt rotation.dat} files), the command line is:
\begin{verbatim}
attract.py -r receptor.red -l ligand.red --ref=ligand.red > docking.att &
\end{verbatim}

The output file {\tt docking.att} contains all informations on the docking simulation. 
It contains the ouput of all series of minimizations (with the specification of translation and rotation number).

For the 1CGI complex, the systematic docking took 19 hours on a single processor of a 64~bit Intel Xeon 1.86 GHz 2 Go RAM computer.
The size of the output file {\tt docking.att} is roughly 77~Mo.

\subsubsection{Docking output analysis}

The 10 best geometries found during the docking simulation can be listed with

\begin{verbatim}
cat docking.att | egrep -e "^==" | sort -n -k4 | head
\end{verbatim}

For the previsous docking simulation of 1CGI, this gives:

\begin{verbatim}
==      133     92   -58.3541443 1.19429783478
==       73    229   -58.3541441 1.19413397471
==      133     21   -58.3541437 1.19566121232
==       73    235   -58.3541436 1.19394986862
==      136     21   -58.3541424 1.19584401069
==      130    141   -58.3541411  1.1930478392
==      194    219   -58.3541410  1.1961246513
==       73      7   -58.3541406 1.19314844151
==      136    155   -58.3541400 1.19273140092
==      163     70   -58.3541387 1.19596166869
\end{verbatim}

With each column meaning:
\begin{enumerate}
\item tag characters ({\tt ==}) to quickly find the result of each set of minimizations
\item translation number (starts at 1)
\item rotation number (starts at 1)
\item final energy of the complex in RT unit
\item final RMSD in \AA, if the \verb@--ref@ option is provided.
\end{enumerate}

Any simulated ligand structure can be extracted with the script {\tt extract.py}:

\begin{verbatim}
extract.py docking.att ligand.red 133 92 > ligand_1.red
\end{verbatim}

with the parameters:
\begin{itemize}
\item the ouput file of the docking simulation ({\tt docking.att})
\item the initial ligand file ({\tt ligand.red})
\item a translation number ({\tt 133})
\item a rotation number ({\tt 92})
\item an output ligand file ({\tt ligand\_1.red})
\end{itemize}

Fig.~\ref{1CGI_dock} shows the best solution of the docking simulation and the
reference complex. With a RMSD of 1.2~\AA\ between both structures, 
the docking simulation found very well the initial complex structure.

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.30\textwidth]{img/1CGI_dock1_front.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.30\textwidth]{img/1CGI_dock1_top.png}
\caption{Reduced representations of receptor (green), ligand at reference 
position (red) and ligand from the best solution (lowest energy) of the 
docking (blue). Front (A) and top (B) views. Beads have exact van der 
Waals radii.}
\label{1CGI_dock}
\end{figure}


In case an experimental structure of the system is known (as in this example), 
it is possible to calculate the interface RMSD (iRMSD) and the native fraction 
(fnat) as defined by the CAPRI contest \footnote{\tt http://capri.ebi.ac.uk}
using the following scripts:

\begin{verbatim}
irmsd.py receptor.red ligand.red ligand_1.red
fnat.py receptor.red ligand.red ligand_1.red
\end{verbatim}

For iRMSD, output is in \AA\ and fnat is given as a proportion (between 0.0 and 1.0). Parameters are defined as:
\begin{itemize}
\item the receptor file ({\tt receptor.red})
\item the initial ligand file ({\tt ligand.red})
\item the output ligand file ({\tt ligand\_1.red})
\end{itemize}

Our clustering algorithm implemented in {\tt cluster.py} can rapidly filter near identical solutions 
without requiring a preselected number of desired clusters.
The algorithm is based on RMSD comparison and an additional energy criterion can be included 
(see script options, by default RMSD and energy criterions are 1~\AA\ and 1~RT unit respectively).

\begin{verbatim}
cluster.py docking.att ligand.red > docking.clust
\end{verbatim}

with the parameters:
\begin{itemize}
\item an ouput of the docking simulation ({\tt docking.att})
\item the initial ligand file ({\tt ligand.red})
\item an output cluster file ({\tt docking.clust})
\end{itemize}

The first lines of the output cluster file are:

\linenumbers*
\begin{verbatim}
      Trans    Rot          Ener    RmsdCA_ref   Rank   Weight
==      133     92   -58.3541443     1.1942978      1       55
==      196    132   -40.3704483    48.8195971      2        1
==      164    212   -39.3828793     6.4968451      3        2
==       71    102   -38.7843145    14.7084754      4       14
==       73    126   -38.5826662    11.5175880      5        3
==      129    223   -38.3872389    12.3477797      6        3
==      132    245   -38.3429828    14.0028863      7       10
==      133    131   -38.1570360    16.0382603      8       17
\end{verbatim}
\nolinenumbers

Line 1 is a comment line, next lines are clusters. For each cluster (line)
is specified:
\begin{itemize}
\item a representative structure with the corresponding translation and rotation
numbers (column 2, {\tt Trans}, and 3, {\tt Rot}), interaction energy 
(column 4, {\tt Ener}) and RMSD (column 5, {\tt RmsdCA\_ref}) 
from the reference ligand structure
\item the number of the cluster (column 6, {\tt Rank})
\item the number of structures (docking solutions) in this cluster (column
7, {\tt Weight})
\end{itemize}

The large weight of the best solution shows the very good convergence of the
docking simulation.

\subsection{Protein--DNA complex: 1K79}


The 1K79 complex \footnote{\tt http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=1K79} 
has two partners,
\begin{itemize}
\item the ETS protein: chain A, 104 residues, 873 atoms (defined in the following as the receptor)
\item a DNA molecule: chain B and C, 30 bases, 607 atoms (defined in the following as the ligand)
\end{itemize}

\subsubsection{Extraction of the docking partners}

Both partners are extracted automatically with PTools from the Python interpreter:
\begin{verbatim}
from ptools import *
pdb=Rigidbody("1K79.pdb")
selA=pdb.SelectChainId("A")
selB=pdb.SelectChainId("B")
selC=pdb.SelectChainId("C")
WritePDB(selA.CreateRigid(), "receptor.pdb")
WritePDB( (selB | selC).CreateRigid(), "ligand.pdb")
exit()
\end{verbatim}

\subsubsection{Coarse grain reduction}

All-atom molecules are then translated into coarse grain (reduced) molecule for further docking. 

For the receptor (protein): 
\begin{verbatim}
reduce.py --prot receptor.pdb --warnonly > receptor.red
\end{verbatim}

This command generates few warnings due to missing atoms in the Lys436 residue. 
When an atom is missing, the corresponding bead is not created. You will have to check
 if this is an important issue for your system and fix your PDB with your favourite tool.
Please also note that the \verb!reduce! script does not report anything to you if a complete
 residue is missing (this frequently occurs in loops).


\begin{verbatim}
reduce.py --prot receptor.pdb > receptor.red
./at2cg.prot.dat: found the definition of residues ARG GLU GLN LYS TRP MET PHE TYR HIS GLY ASN ALA ASP CYS ILE LEU PRO SER THR VAL 
./at2cg.prot.dat: created the partition for residues ARG(3 beads) GLU(3 beads) GLN(3 beads) LYS(3 beads) TRP(3 beads) MET(3 beads) PHE(3 beads) TYR(3 beads) HIS(3 beads) GLY(1 beads) ASN(2 beads) ALA(2 beads) ASP(2 beads) CYS(2 beads) ILE(2 beads) LEU(2 beads) PRO(2 beads) SER(2 beads) THR(2 beads) VAL(2 beads) 
./ff_param.dat: reading force field parameters for bead 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 
Load atomic file receptor.pdb with 873 atoms 
Number of residues: 104
Reading all atoms and filling beads:
Coarse graining:
ERROR: missing atom CG in bead CB 16 for residue LYS 436. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom CE in bead CE 17 for residue LYS 436. Please fix your PDB!
Continue execution as required ...
Coarse grain (reduced) output: 246 beads 
\end{verbatim}

The reduced protein, {\tt receptor.red}, contains 246 beads.\\

For the ligand (DNA), do not forget the \verb@--dna@ option:
\begin{verbatim}
reduce.py --dna ligand.pdb --warnonly > ligand.red
\end{verbatim}
This also generates few warnings due to incomplete bases:
\begin{verbatim}
./at2cg.dna.dat: found the definition of residues A G C T 
./at2cg.dna.dat: created the partition for residues A(6 beads) G(6 beads) C(5 beads) T(5 beads) 
./ff_param.dat: reading force field parameters for bead 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 
Load atomic file ligand.pdb with 607 atoms 
Number of residues: 30
Reading all atoms and filling beads:
Coarse graining:
ERROR: missing atom O1P in bead GP1 30 for residue T 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom O2P in bead GP1 30 for residue T 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom P in bead GP1 30 for residue T 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom O1P in bead GP1 30 for residue C 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom O2P in bead GP1 30 for residue C 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom P in bead GP1 30 for residue C 1. Please fix your PDB!
Continue execution as required ...
Coarse grain (reduced) output: 162 beads
\end{verbatim}

The reduced DNA, {\tt ligand.red}, ends up with 162 beads. \\

As previously said, the reduced files generated are PDB-like structure files 
that can be read by most visualization programs (Rasmol, Pymol, VMD). 
Always visualize both all-atom and coarse grain structures to check the 
reduction worked properly (see Fig.~\ref{1K79_at_cg} for 1K79).

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.35\textwidth]{img/1K79_receptor.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.20\textwidth]{img/1K79_ligand.png}
\caption{All-atom (green sticks) and reduced (red spheres) representation 
of both partners in 1K79. Receptor, protein (A) and ligand, DNA (B).}
\label{1K79_at_cg}
\end{figure}

\subsubsection{Initial ligand position}

\begin{verbatim}
translate.py receptor.red ligand.red > translation.dat
\end{verbatim}

In the present case, the {\tt translation.dat} file contains 179 starting points.

\subsubsection{ATTRACT parameters}

The content of the {\tt attract.inp} parameters file is identical to the one
previously used for protein--protein docking.

\subsubsection{Simple optimization}

An ATTRACT optimization is done with:
\begin{verbatim}
attract.py -r receptor.red -l ligand.red --ref=ligand.red -s > single.att
\end{verbatim}

Here, the final energy is -38.4~RT unit and the RMSD is 1.3~\AA\ which is very close
from the initial position.

Please note that the RMSD is not computed here on C$_{\alpha}$ atoms since the
ligand is a DNA molecule. The RMSD is calculated using all DNA beads. 

\subsubsection{Systematic docking simulation}

A systematic docking simulation is then:
\begin{verbatim}
attract.py -r receptor.red -l ligand.red --ref=ligand.red > docking.att &
\end{verbatim}

The output file {\tt docking.att} contains all informations on the docking 
simulation. It contains the ouput of all series of minimizations 
(with the specification of translation and rotation numbers).

For the 1K79 complex, the systematic docking took roughly 11 hours on a single processor of a 64~bit Intel Xeon 1.86 GHz 2 Go RAM computer.
The size of the output file {\tt docking.att} is about 67~Mo.

\subsubsection{Docking output analysis}

The 10 best geometries found during the docking simulation can be listed with :

\begin{verbatim}
cat docking.att | egrep -e "^==" | sort -n -k4 | head
\end{verbatim}

This gives:

\begin{verbatim}
==       30    157   -38.4463924 1.25369709657
==      169     51   -38.4463903 1.25534808001
==      148    234   -38.4463875 1.25581284912
==       87    257   -38.4463867 1.25409925951
==      109    231   -38.4463855 1.25469537295
==      104    236   -38.4463848 1.25571565339
==      144     27   -38.4463848 1.25495212761
==      164    255   -38.4463819 1.25410121719
==      163     27   -38.4463817 1.25446355377
==       87    241   -38.4463806  1.2554586922
\end{verbatim}


We can then extract the best structure obtained (translation number 30 
and rotation number 157, illustrated Fig.~\ref{1K79_dock}):

\begin{verbatim}
extract.py docking.att ligand.red 30 157 > ligand_1.red
\end{verbatim}

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.30\textwidth]{img/1K79_dock1_front.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.30\textwidth]{img/1K79_dock1_top.png}
\caption{Reduced representations of receptor (green), ligand at reference 
position (red) and ligand from the best solution (lowest energy) of the 
docking (blue). Front (A) and top (B) views. Beads have exact van der Waals 
radii. With a RMSD of 1.6~\AA\ between the reference and the simulated ligand 
structures, the docking simulation found very well the initial complex 
structure.}
\label{1K79_dock}
\end{figure}

As for protein--protein example, one can compute the native fraction (fnat).
\begin{verbatim}
fnat.py receptor.red ligand.red ligand_1.red
\end{verbatim}

That gives {\tt 0.824561403509} in this example. However, the interface 
RMSD (iRMSD) calculation is not yet implemented for DNA.


Our clustering algorithm implemented in {\tt cluster.py} can rapidly group
near identical solutions without requiring a preselected number of desired clusters.
The algorithm is based on RMSD comparison and an additional energy criterion can 
be included (see script options, by default RMSD and energy criterions are 
1~\AA\ and 1~RT unit respectively).

\begin{verbatim}
cluster.py docking.att ligand.red > docking.clust
\end{verbatim}

The first lines of the output cluster file are:

\linenumbers*
\begin{verbatim}
      Trans    Rot          Ener    RmsdCA_ref   Rank   Weight
==       30    157   -38.4463924     1.2536971      1       46
==      152    180   -36.8164268    29.0984166      2       17
==       97    155   -36.3644447    28.7048437      3       21
==       98     56   -36.0763672     6.3710149      4       22
==       32    244   -35.1526795    28.8685938      5       31
==       24      9   -34.8754859    12.7403727      6       13
==      146     15   -34.3673609    20.3370509      7       13
==      150    210   -33.6537513    17.1449536      8       17
\end{verbatim}
\nolinenumbers

The large weight of the best solution shows the very good convergence of the
docking simulation.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Modeling proteins filaments: Heligeom}
% This part shows the Ptools helicoidal modeling application called heligeom. It can
% modelize helicoidal protein filaments but also linear and circular filaments, as 
% the screw movement can represent any kind of motion. 
This part presents the PTools helical modeling application called {\verb!heligeom!}. It can
model helical protein filaments but also linear or circular filaments. Such filament
geometries result from generic displacements known as screw movements, which represent any kind of rigid body motion. 

The {\tt heligeom} tool can be used both for analysis and for filament construction.


\subsection{Circular filaments: 2GLS}
Analysis and construction with {\verb!heligeom!} requires to have the tridimensional structure of two successive monomers of the filament under study. 
% To use heligeom, one have to obtain two successives monomer of the filament one wish to study. 
In this example, we will separate part of the circular filament 2GLS, available in the PDB. This is easily done with PTools :
\begin{verbatim}
from ptools import *
pdb = Rigidbody("2GLS.pdb")

selA = (pdb.SelectChainId("A")|pdb.SelectChainId("G"))
selB = (pdb.SelectChainId("B")|pdb.SelectChainId("H"))

pdbA = selA.CreateRigid()
pdbB = selB.CreateRigid()

WritePDB(pdbA,"2GLS_A.pdb")
WritePDB(pdbB,"2GLS_B.pdb")
\end{verbatim}

\subsection{Helical parameters}
% You can obtain the helecoidal parameters with this line:
The helical parameters can be obtained with this line:
\begin{verbatim}
python heligeom.py 2GLS_A.pdb 2GLS_B.pdb
\end{verbatim}
{\verb!heligeom!} should print back the following text:

% quality (Rmsd): 1.45455791411e-14
% 
\begin{verbatim}
P:      0.000391407  -0.000206358  0
omega:  -3.29384e-07  -2.6531e-07  1
theta:  -1.04719853184
trans   0.00026971416906

monomers per turn:        5.99999438135
pitch:  0.00161828349893
direction : R
\end{verbatim}

% There is for parameters to describe the screw motion.first, a vector omega and a point P to form the axis and second, the angle theta ( in radian ) of the rotation and the translation trans to aply along the axis. This for parameters are ilustrated on Fig.~\ref{screw}. Finally, heligeom provide the number of monomer by turn and the pitch (the distance between the monomers at the ends of a complete turn).
The first four lines describe the screw motion. 
A point $P$ and a vector $omega$ define the rotation axis; 
the rotation angle $theta$ (in radian) and the translation $trans$ define the transformation that needs to be applied along the axis to go from one monomer to the next one. 
These four components of the screw transformation are illustrated on Fig.~\ref{screw}. 
Finally, \texttt{heligeom} provides information on the global geometry of the resulting filament: 
number of $monomers~per~turn$, $pitch$ (the distance between the monomers separated by a complete turn) and $direction$ of rotation.

\begin{figure}[htbp]
\center
\includegraphics*[width=0.50\textwidth]{img/schema_heligeom.pdf}
\caption{Schema of the screw motion model used in \texttt{heligeom} between two monomers A and B.}
\label{screw}
\end{figure}
\newpage
\subsection{Modeling}
% With the four screw motion parameters, you can extend your two monomer as you want to form a longer helix. such operation is easily done with heligeom by giving the wanted number of monomers as argument :
Once the four screw motion components have been determined, it is possible to extend the two monomer section to form a longer helix of arbitrary size. 
Such operation is easily done with {\tt heligeom} by providing the wanted number of monomers as argument :
      
\begin{verbatim}
python heligeom.py 2GLS_A.pdb 2GLS_B.pdb 6 > new_2GLS.pdb
\end{verbatim}
% You can also precize a "-Z" option to align your helix on the Z axis.
One can also specify a "-Z" option to align the helix of the generated filament on the Z axis.

The result can be visualized with pymol, as illustrated in Fig.~\ref{2gls}:
% You can visualize the result with pymol,as illustrated Fig.~\ref{2gls}:
\begin{verbatim}
pymol new_2GLS.pdb
\end{verbatim}

\begin{figure}[htbp]
\center
\includegraphics*[width=0.60\textwidth]{img/2GLS.png}
\caption{The circular filaments 2GLS as modelized with \texttt{heligeom} from two monomers A and B (in cyan and red respectively).}
\label{2gls}
\end{figure}


One can also use another tool to form an helix along an arbitrary axis, again using the screw motion parameters that have been determined from the two monomer complex. For this exemple we will use a different protein. After downloading the PDB file 3CMT, one canuse the following code to obtain two monomers:
\begin{verbatim}
rig =Rigidbody("3CMT.pdb")
m1 = rig.SelectChainId ("A") & rig.SelectResRange (2000,2999)
m2 = rig.SelectChainId ("A") & rig.SelectResRange (3000,3999)

WritePDB (m1.CreateRigid () , "3CMT_m1.pdb")
WritePDB (m2.CreateRigid () , "3CMT_m2.pdb")
\end{verbatim}       
First, an arbitrary axis needs to be generated. Here is an exemple of a script that generates such axis (let us call it "genAxis.py")
\begin{verbatim}
from ptools import *

l=[]
r =Rigidbody()
r.AddAtom (Atom (Atomproperty(), Coord3D (20,0,0)))
m=(Rise(0.7)+Roll(0.1)).getMatrix()

for i in xrange(0,2000):
     r.ApplyMatrix(m)
     print r.PrintPDB(),
\end{verbatim} 

Generate the axis file:
\begin{verbatim}
python genAxis.py > axis.pdb
\end{verbatim}

Then call the script buildProteinAlongAxis.py : 
\begin{verbatim}
python buildProteinAlongAnAxis.py axis.pdb 3CMT_m1.pdb 3CMT_m2.pdb > new.pdb
\end{verbatim}

Optionally, an angle can be specified to operate a rotation around the axis (the first monomer is rotated, then the helix is constructed with respect to this rotated monomer). The angle is given in degree.

\begin{verbatim}
python buildProteinAlongAnAxis.py axis.pdb 3CMT_m1.pdb 3CMT_m2.pdb 180 > new2.pdb
\end{verbatim}

Although the script was made for treating proteins, it accepts any kind of pdb file.

\subsection{Helix and docking simulations}

PTools offers scripts to rank docking simulation results by helical properties, such as the number of monomers per turn or the pitch. First, the docking results (let us call them {\tt myResult.att"}) need to be transformed with the following script.
\begin{verbatim}
python extractHelicoidalParameter.py myResult.att receptor.red > h-parameter.txt
\end{verbatim}

The file {\tt h-parameter.txt} will look something similar to what follows:
\begin{verbatim}
1 1 2.71407733582 79.9787435719 L -12.5671003
1 2 2.98516008093 66.1655247583 R -19.7301312
1 3 19.5744814746 1713.82947959 R -0.0004227
...
\end{verbatim}
The first two columns are the rotation and translation numbers, which are unique to each individual optimization (\textit{i.e.} series of minimizations starting from the initial geometry defined by these two numbers). The third column is the number of monomers per turn and the fourth is the pitch. The fifth column indicates whether the helix is left-handed (L) or rigth-handed (R). Finally the last column gives the energy of interaction at the end of the optimization.
  
The following script specifies a range of selected values for the number of monomers per turn, the pitch or the direction of rotation (left- or rigth-handed).
\begin{verbatim}
python filterHelicodalParameters.py h-parameter.txt --pitch 30 50 
--nbMono 5 6 --direction R
\end{verbatim}

One can also use the abbreviated form :
\begin{verbatim}
python filterHelicodalParameters.py h-parameter.txt -p 30 50 -n 5 6 -d R
\end{verbatim}

This will return a list all predictions corresponding to the specified criteria, ordered by energy. The PDB model corresponding to a chosen prediction can be generated from the translation and rotation numbers, using the following script:
\begin{verbatim} 
python extractHelicoidalModel.py myResult.att receptor.pdb 124 57 > myHelix.pdb 
\end{verbatim}
This command line returns a whole turn of the helix. If more than one turn is needed, one can notify the desired number of turns :\begin{verbatim} 
python extractHelicoidalModel.py myResult.att receptor.pdb 124 57 3 > myHelix-3turns.pdb 
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DNA manipulation with PTools}

\subsection{Introduction}

To manipulate oligonucleotides in PTools, one can of course use a Rigidbody() object, but PTools also provides a special object, called DNA(), to operate advanced operations on double stranded DNA.

\subsubsection{DNA object}
There are many ways to create a DNA() object. It can be created empty:
\begin{verbatim}
d = DNA()
\end{verbatim}
Or from another DNA() object:
\begin{verbatim}
d = DNA(old_d)
\end{verbatim}
One can also generate a new DNA() from a PDB file. 
In that case, a base pair data file is required, which contains the reference structure and characteristics of each base pair.  
Two examples of such files are provided with PTools, see the "Base pair files" section for more details.
\begin{verbatim}
d = DNA("pb.aa.pdb","mydna.pdb")
\end{verbatim}       
Finally it is possible to generate a completely new DNA() by providing the base pair data file, the DNA sequence and the parameters describing how each base pair is positioned with respect to the preceding one. Such parameters are held in the PTools object Movement(), which is described in detail in the section "Regular conformation" 
\begin{verbatim}
d = DNA("pb.aa.pdb","AATTGCTTAA",BDNA())
\end{verbatim} 

It is easy to make the transition from DNA() to Rigidbody() or from Rigidbody() to DNA().

\begin{verbatim}
mydna = DNA("pb.aa.pdb",myRigidbody)
myNewRigidbody = mydna.CreateRigid() 
\end{verbatim} 

One can also obtain the rigidbody of only one strand easily.

\begin{verbatim}
rigidStrandA = mydna.createRigidOfStrand ("A")
\end{verbatim} 
\subsubsection{BasePair object}
The object BasePair() is a convenient way to hold the base pair data of the DNA() object. Individual base pairs can be easily accessed.
\begin{verbatim}
d = DNA("pb.aa.pdb","AAAAA",BDNA())
basePairNumber2 = d[1] #numeration starts at 0
\end{verbatim} 

again, it is possible to obtain the Rigidbody() of a given base pair.
\begin{verbatim}
myRigidbody = d[1].getRigidBody() 
\end{verbatim} 

\subsubsection{Base pair files}
PTools needs data to build or reconstruct DNA(). Such data are provided by the base pair data files. Two of these files can be found in the {\tt DNA/} directory. Using the file {\tt "pb.aa.pdb"} permits to generate base pairs in all atom representation while the {\tt "pb.cg.pdb"} file provides base pair in coarse grain representation such as the one used in docking simulation. 
Once created, the representation of a DNA can be easily modified.

\begin{verbatim}
myAllAtomDNA = myCoarseGrainDNA.changeRepresentation("pb.aa.pdb")
\end{verbatim} 

\subsubsection{Regular conformation}
For a rigid body, there are six degrees of freedom: three translations and three rotations. A change from a set of these six values to a new set of values of the degrees of freedom can be represented by a matrix, but for convenience PTools also provides a Movement() object.
% Note that the Movement() object can be used in equivalent ways to characterize the motion of an object or the positioning of a second object with respect to the first one.
 
One can easily make the transition to and from a matrix.

\begin{verbatim}
mov = Movement(matrix)
matrix = mov.getMatrix()
\end{verbatim} 

Again for convenience's sake, special objects inherited from Movement() are provided to define rotation or translation. Rotations are given in degree. The next lines characterize a rigid body movement with 2~{\AA} translations in all three directions and 15 degree rotations in all three rotational directions. 
\begin{verbatim}
mov = Shift (2) #translation along x (short axis)
mov = Slide (2) #translation along y (long axis)
mov = Rise  (2) #translation along z (perpendicular axis)
mov = Twist(15) #rotation around z (perpendicular axis)
mov = Roll (15) #rotation around y (long axis) 
mov = Tilt (15) #rotation around x (short axis)
\end{verbatim} 
 
Individual Movement() can be combined to form a new movement, as shown below. Note that there is a special order to mix the translations and each of the three rotations : 

\begin{verbatim}
mov = Twist( 31.1 )+Roll( 2.0 )+Tilt( 2.1 )+Rise( 3.3 )+Slide( -2.4 )+Shift( -0.5 )
\end{verbatim} 


Standard DNA conformations such as B-DNA and A-DNA can easily be generated using either of two pre-defined Movement() objects . The first object, BDNA(), is for DNA in B conformation. the second one, ADNA() is, as can be guessed, for a A-form DNA.
 
To obtain the parameters of a specific DNA conformation with available structure, one can use the {\tt "computeParametersOfDNA.py"} script provided in the {\tt DNA/} directory.
\begin{verbatim}
python computeParametersOfDNA.py mydna.pdb
\end{verbatim} 

\subsection{Exemple}
\subsubsection{Edition}

The type of a base pair (A,T,G,C) may be changed by a simple instruction. Here, the first base pair is changed into an ``A.T'' base pair.
\begin{verbatim}
d.changeType(0,"A","pb.cg.pdb")
\end{verbatim}

Below is a simple script to change the complete sequence of a DNA (provided the lengths of the old and new sequence are the same): 
\begin{verbatim}
d = DNA("pb.cg.pdb","mydna.pdb" )
for i,c in enumerate ("AAATTATTTTACTCTGTGTAATAAATAAAA"):
    d.changeType(i,c,"pb.cg.pdb")
\end{verbatim} 

Concatenation of two DNAs is possible using the {\tt add()} function.
%When you have more than one DNA, you can "add" one to the other. 
This places the second DNA at the end of the first one, with the provided movement between them. By default a BDNA() movement is provided.
\begin{verbatim}
d1 = DNA("pb.aa.pdb","AAAAT",BDNA())
d2 = DNA("pb.aa.pdb","GCCCC",ADNA())
d1.add(d2) # the last base T of d1 will be connected to the first base G of d2
\end{verbatim}

One can also "extract" a DNA from a bigger one using the {\tt subDNA()} function.
 
\begin{verbatim}
new_d =d.subDNA(1,3) # will create a new dna of 3 base pairs
\end{verbatim}
 
\subsubsection{Moves}
The position of a DNA can be modified by applying a translation vector ...
\begin{verbatim}
d.translate(Coord3D(0,5,0))
\end{verbatim}

... or a transformation matrix (or {\tt Movement})
\begin{verbatim}
d.apply(Slide(5))
\end{verbatim}

The same transformations can be applied to a selected base pair. In that case, the change will be done relatively to the local frame of the base pair.
\begin{verbatim}
d.applyLocal(Slide(5),2)# will displace the third base pair along the Y axis by 5~\AA 
\end{verbatim}

This operation can modify the position of the DNA base pairs which follow the base pair submitted to transformation. In case this displacement is unwanted, one can anchor a specified DNA base pair, thus indicating which part will not move. For example in the next command, base pair number 5 is defined as an anchor. Application of the slide movement will result in the DNA section from base pair 0 to 2 being displaced with respect to the section from base pair 5 on. 
\begin{verbatim}
d.applyLocal(Slide(5),2,0)
\end{verbatim}


Finally, one can apply a transformation simultaneously on each base pair with a unique command:
\begin{verbatim}
d.applyGlobal(Slide(5)) 
\end{verbatim}
    
\subsection{DNA and Axis}
A DNA specific counterpart to the PTools/\texttt{heligeom} application that constructs helices around a given axis has been implemented. 

Using the \texttt{axis.pdb} file generated in section  ``Modeling proteins filaments: Heligeom'', it is trivial to generate a DNA structure around that axis:

\begin{verbatim}
python buildDNAalongAnAxis.py  axis.pdb > myDNA.pdb
\end{verbatim} 


The new DNA may not necessarily present a convenient phase. 
It can be rotated around its axis with the rotateDNAaroundAxis.py command, with performs the rotation by given angle value (in degree, here 15 degrees).

\begin{verbatim}
python rotateDNAaroundAxis.py axis DNA.pdb 15 > myNewDNA.pdb
\end{verbatim} 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Misc. tips and tricks}


\subsection{Troubleshooting}

\subsubsection{Bus error}

On Mac OS, the command \verb@import ptools@ can lead to a "bus error" 
error message. This happens with MacPorts or fink versions of Python. 
A solution is to use the Python provided with the system instead 
(\verb@/usr/bin/python@).

\subsection{Accurate bead representation}

Adjustment of van der Waals radii is recommended for a more accurate 
representation of the occupied volume. In this purpose, we provide a Pymol 
script called \verb@update_pymol_cg_vdw_radii.pml@ in the 
\verb@$HOME/ptools-XX/PyAttract@ directory. Within Pymol, call this 
script with the command
\begin{verbatim}
run update_pymol_cg_vdw_radii.pml
\end{verbatim}
or from the menu {\tt File -> Run -> select the file}.

With some representations (dots, spheres, mesh and surface), you also need 
to tell Pymol to refresh its view with the command {\tt rebuild}.
Coarse grain van der Waals radii have now their real values and 
reduced molecules their real volume, as shown in Fig.~\ref{real_vdw}.

\begin{figure}[Htbp]
\center
{\textbf A}
\includegraphics*[width=0.15\textwidth]{img/1K79_dna.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.20\textwidth]{img/1K79_prot.png}
\caption{All-atom (green mesh) and reduced (red mesh) representations of both 
partners in the 1K79 protein--DNA complex. With the correct values of coarse grain
van der Waals radii, both representations are equivalent.
DNA (A) and protein (B).}
\label{real_vdw}
\end{figure}

\subsection{Minimization movie}

Here is the procedure to visualize all conformations taken by the ligand during minimizations.

\begin{enumerate}
\item Place the ligand at the wanted translation and rotation.
\begin{verbatim}
startligand.py ligand.red translation_number rotation_number
\end{verbatim}
This will generate the file \verb=ligand_X_Y.red= where \verb=X= and \verb=Y= are the translation and rotation numbers, respectively.
\item Launch a docking simulation in single mode
\begin{verbatim}
attract.py receptor.red ligand_X_Y.red --ref=ligand.red -s > single.att
\end{verbatim}
The file \verb=minimization.trj= is created and contains the 6 variables of translation and rotation for all steps of all minimizations.
\item Convert translation/rotation variables into ligand conformations
\begin{verbatim}
applytraj.py minimization.trj ligand_X_Y.red > ligand_moves.red
\end{verbatim}
The file \verb=ligand_moves.red= is a multi-pdb files containing all conformations of the ligand at each step of the minimizations.
\item Visualize \verb=ligand_moves.red= with PyMoL or VMD. For instance with Pymol:
\begin{verbatim}
pymol ligand_moves.red
\end{verbatim}
You could also represent the receptor:
\begin{verbatim}
pymol receptor.red ligand_moves.red
\end{verbatim}
\end{enumerate}

 

\bibliography{biblio}{}
\bibliographystyle{plain}


\end{document}


		
